<!-- Programming Taskbook 4.8 | Copyright (c) M. Abramyan, 1998-2009 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:0px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;}
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
TT{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Одномерные массивы</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2006, 2012</p>
<p class="ptComment"> Условие вида &#171;дан массив размера <i>N</i>&#187; означает, что вначале дается <i>фактический размер</i> массива (целое число <i>N</i>), а затем приводятся все его элементы. Если в задании явно не указывается, какие значения может принимать размер исходного массива, то предполагается, что размер может изменяться в пределах от&nbsp;2 до&nbsp;10. Индекс начального элемента массива считается равным&nbsp;1. </p><p class="ptComment">Если в задании, связанном с созданием (преобразованием) массива, не описан результирующий набор данных, то предполагается, что этим набором является созданный (преобразованный) массив, и необходимо вывести все его элементы в порядке возрастания их индексов.</p>
<h2>Одномерные массивы: анализ элементов</h2>
<p class="ptComment"> Для выполнения некоторых заданий, связанных с анализом элементов массива, не требуется одновременно хранить в памяти все исходные данные, поэтому использовать при их выполнении массивы, строго говоря, <i>не нужно</i>. Однако применение массивов позволяет сделать алгоритмы решения этих заданий более простыми и наглядными. Задания из данного пункта можно дополнить заданиями из групп &#171;Последовательности&#187; и &#171;Минимумы и максимумы&#187;, рассматривая их как задания на обработку массивов. С другой стороны, для тех заданий данной группы, которые можно выполнить, не используя массивы, полезно реализовать и такие алгоритмы решения.</p>
<p class="ptTask"><span class="ptSpecial">Array37</span>. Дан массив размера&nbsp;<i>N</i>. Найти количество участков, на которых его элементы возрастают. </p>
<p class="ptTask"><span class="ptSpecial">Array50</span>. Дан целочисленный массив&nbsp;<i>A</i> размера&nbsp;<i>N</i>, являющийся перестановкой (определение <i>перестановки</i> дано в задании Array49). Найти количество <i>инверсий</i> в данной перестановке, т.&nbsp;е. таких пар элементов&nbsp;<i>A</i><sub><i>I</i></sub> и&nbsp;<i>A</i><sub><i>J</i></sub>, в которых большее число находится слева от меньшего: <i>A</i><sub><i>I</i></sub>&nbsp;&gt;&nbsp;<i>A</i><sub><i>J</i></sub> при <i>I</i>&nbsp;&lt;&nbsp;<i>J</i>. </p>
<h2>Одномерные массивы: преобразование</h2>
<p class="ptComment"> При выполнении заданий на преобразование массива не следует использовать вспомогательные массивы.</p>
<p class="ptTask"><span class="ptSpecial">Array100</span>. Дан целочисленный массив размера&nbsp;<i>N</i>. Удалить из массива все элементы, встречающиеся ровно два раза, и вывести размер полученного массива и его содержимое. </p>
<h2>Одномерные массивы: серии целых чисел</h2>
<p class="ptTask"><span class="ptSpecial">Array129</span>. Дан целочисленный массив размера&nbsp;<i>N</i>. Преобразовать массив, увеличив его последнюю серию наибольшей длины на один элемент (определение серии дано в задании Array116). </p>
<h1>Двумерные массивы (матрицы)</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2006, 2012</p>
<p class="ptComment"> Условие вида &#171;дана матрица размера <i>M</i>&nbsp;&#215;&nbsp;<i>N</i>&#187; означает, что вначале дается <i>фактический размер</i> двумерного массива-матрицы (количество строк <i>M</i> и количество столбцов <i>N</i>), а затем приводятся элементы этого массива (количество элементов равно <i>M</i>&#183;<i>N</i>). Если в задании явно не указывается, какие значения могут принимать размеры исходной матрицы, то предполагается, что и число строк, и число столбцов может изменяться в пределах от&nbsp;2 до&nbsp;10. Начальные значения как первого, так и второго индекса двумерного массива-матрицы всегда считаются равными&nbsp;1. Ввод и вывод элементов матрицы осуществляются <i>по строкам</i>. </p><p class="ptComment"><i>Квадратной матрицей порядка</i> <i>M</i> называется двумерный массив-матрица размера <i>M</i>&nbsp;&#215;&nbsp;<i>M</i>. </p><p class="ptComment">Если в задании, связанном с созданием или преобразованием матрицы, не описан результирующий набор данных, то предполагается, что этим набором является созданная (преобразованная) матрица, и необходимо вывести все ее элементы.</p>
<h2>Двумерные массивы (матрицы): анализ элементов</h2>
<p class="ptTask"><span class="ptSpecial">Matrix28</span>. Дана матрица размера&nbsp;<i>M</i>&nbsp;&#215;&nbsp;<i>N</i>. Найти минимальный среди максимальных элементов ее столбцов. </p>
<p class="ptTask"><span class="ptSpecial">Matrix43</span>. Дана матрица размера&nbsp;<i>M</i>&nbsp;&#215;&nbsp;<i>N</i>. Найти количество ее столбцов, элементы которых упорядочены по убыванию. </p>
<h2>Двумерные массивы (матрицы): преобразование</h2>
<p class="ptComment"> При выполнении заданий на преобразование матриц не следует использовать вспомогательные двумерные массивы-матрицы, за исключением тех заданий, в которых явно сказано о допустимости применения вспомогательных матриц.</p>
<p class="ptTask"><span class="ptSpecial">Matrix77</span>. Дана матрица размера&nbsp;<i>M</i>&nbsp;&#215;&nbsp;<i>N</i>. Упорядочить ее столбцы так, чтобы их последние элементы образовывали убывающую последовательность. </p>
<h1>Символы и&nbsp;строки</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2006, 2012</p>
<p class="ptComment"> При выполнении заданий на обработку русских букв можно считать, что буква &#171;ё&#187; в исходных строковых данных отсутствует.</p>
<h2>Символы и&nbsp;строки: основные операции</h2>
<p class="ptComment"> В заданиях, связанных с поиском и заменой подстрок, можно считать, что исходная строка не содержит <i>перекрывающихся</i> вхождений требуемых подстрок. Кроме этого, можно также считать, что удаление или замена любого вхождения подстроки не приведет к появлению в строке <i>новых</i> вхождений данной подстроки.</p>
<p class="ptTask"><span class="ptSpecial">String24</span>. Дана строка, изображающая двоичную запись целого положительного числа. Вывести строку, изображающую десятичную запись этого же числа. </p>
<h2>Символы и&nbsp;строки: дополнительные задания</h2>
<p class="ptTask"><span class="ptSpecial">String67</span>. Дано предложение, зашифрованное по правилу, описанному в задании String66. Расшифровать это предложение. </p>
<h2>Символы и&nbsp;строки: основные операции</h2>
<p class="ptComment"> В заданиях, связанных с поиском и заменой подстрок, можно считать, что исходная строка не содержит <i>перекрывающихся</i> вхождений требуемых подстрок. Кроме этого, можно также считать, что удаление или замена любого вхождения подстроки не приведет к появлению в строке <i>новых</i> вхождений данной подстроки.</p>
<p class="ptTask"><span class="ptSpecial">String39</span>. Дана строка, содержащая по крайней мере один символ пробела. Вывести подстроку, расположенную между первым и вторым пробелом исходной строки. Если строка содержит только один пробел, то вывести пустую строку. </p>
<h2>Анализ и&nbsp;преобразование слов в&nbsp;строке</h2>
<p class="ptComment"> Во всех заданиях данной подгруппы предполагается, что исходные строки являются непустыми и не содержат начальных и конечных пробелов.</p>
<p class="ptTask"><span class="ptSpecial">String56</span>. Дана строка-предложение на русском языке. Вывести самое короткое слово в предложении. Если таких слов несколько, то вывести последнее из них. <i>Словом</i> считать набор символов, не содержащий пробелов, знаков препинания и ограниченный пробелами, знаками препинания или началом/концом строки. </p>
<h2>Символы и&nbsp;строки: дополнительные задания</h2>
<p class="ptTask"><span class="ptSpecial">String59</span>. Дана строка, содержащая <i>полное имя файла</i>, т.&nbsp;е. имя диска, список каталогов (путь), собственно имя и расширение. Выделить из этой строки расширение файла (без предшествующей точки). </p>
<h1>Двоичные файлы</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2006, 2012</p>
<p class="ptComment"> Под <i>двоичным файлом</i> понимается файл, содержащий элементы одного типа в специальном формате. </p><p class="ptComment">В языке C++ для работы с двоичными файлами надо открывать их в режиме <tt>ios_base::binary</tt>; для чтения и записи элементов двоичных файлов в языке C++ надо использовать методы <tt>read</tt> и <tt>write</tt> со списком параметров вида <tt>((char *)&amp;x, sizeof(x))</tt>, где <tt>x</tt> - переменная, тип которой совпадает с типом элементов двоичного файла. </p><p class="ptComment">Условие вида &#171;дан файл (целых чисел, вещественных чисел и т.&nbsp;д.)&#187; означает, что в наборе исходных данных указано <i>имя</i> данного файла (текстовая строка), а сам исходный файл существует и находится в текущем каталоге. Если существование исходных файлов требуется проверять в ходе выполнения задания, то это особо оговаривается в формулировке задания. Элементы исходных файлов следует считывать с помощью стандартных процедур используемого языка программирования. </p><p class="ptComment">Если в задании требуется создать новый файл, то имя создаваемого файла также входит в набор исходных данных и обычно является <i>последним</i> элементом этого набора. Записывать элементы в создаваемые (или модифицируемые) файлы следует с помощью стандартных процедур используемого языка программирования. </p><p class="ptComment">Под <i>размером</i> типизированного файла всегда подразумевается количество содержащихся в нем <i>элементов</i> указанного типа (а не количество байтов, как это принято в операционной системе). В заданиях предполагается, что файловые элементы нумеруются от&nbsp;1. </p><p class="ptComment">Если о минимальном размере исходного файла в задании ничего не сказано, то предполагается, что он равен&nbsp;2 (т.&nbsp;е. файл содержит по крайней мере два элемента). Максимальный размер исходных файлов не устанавливается, поэтому при решении заданий не следует использовать вспомогательные массивы, содержащие все элементы исходных файлов, однако допускается использование <i>вспомогательных файлов</i>.</p>
<h2>Двоичные файлы: основные операции</h2>
<p class="ptTask"><span class="ptSpecial">File11</span>. Дан файл вещественных чисел. Создать два новых файла, первый из которых содержит элементы исходного файла с нечетными номерами (1,&nbsp;3,&nbsp;&#8230;), а второй &#8212; с четными (2,&nbsp;4,&nbsp;&#8230;). </p>
<p class="ptTask"><span class="ptSpecial">File19</span>. Дан файл вещественных чисел. Найти его последний локальный максимум (<i>локальным максимумом</i> называется элемент, который больше своих соседей). </p>
<p class="ptTask"><span class="ptSpecial">File32</span>. Дан файл целых чисел, содержащий четное количество элементов. Удалить из данного файла первую половину элементов. </p>
<h2>Работа с&nbsp;несколькими числовыми файлами. Файлы-архивы</h2>
<p class="ptTask"><span class="ptSpecial">File53</span>. Дана строка <i>S</i>, целое число <i>N</i> (&gt;&nbsp;0) и файл-<i>архив</i> целых чисел, содержащий данные из нескольких файлов в формате, описанном в задании File52. Восстановить из файла-архива файл с номером&nbsp;<i>N</i> и сохранить его под именем&nbsp;<i>S</i>. Если файл-архив содержит данные из менее чем <i>N</i>&nbsp;файлов, то оставить результирующий файл пустым. </p>
<h2>Символьные и&nbsp;строковые файлы</h2>
<p class="ptComment"> <i>Строковым файлом</i> называется двоичный файл, элементами которого являются текстовые строки. </p><p class="ptComment">При выполнения заданий на языке C++ следует считать, что элементы строковых файлов имеют тип <tt>char[80]</tt>.</p>
<p class="ptTask"><span class="ptSpecial">File69</span>. Дан строковый файл, содержащий даты в формате, описанном в задании File67. Создать новый строковый файл, содержащий все летние даты из исходного файла (в том же порядке). Если даты с требуемым временем года в файле отсутствуют, то оставить результирующий файл пустым. </p>
<h2>Использование файлов для&nbsp;работы с&nbsp;матрицами</h2>
<p class="ptComment"> <i>Матрицей</i> размера <i>M</i>&nbsp;&#215;&nbsp;<i>N</i> называется прямоугольная таблица чисел, содержащая <i>M</i> строк и <i>N</i> столбцов. Для работы с матрицами обычно используются <i>двумерные массивы</i> (см. задания группы Matrix). Данная подгруппа посвящена способам обработки матриц, хранящихся в типизированных файлах на внешних носителях (дисках). Как и в остальных заданиях на обработку файловых данных, при выполнении заданий из данной подгруппы <i>не следует</i> использовать вспомогательные массивы, содержащие все файловые элементы. </p><p class="ptComment">В заданиях данной подгруппы используются дополнительные понятия теории матриц. Приведем определения этих понятий. </p><p class="ptComment">Пусть <i>A</i> &#8212; матрица размера <i>M</i>&nbsp;&#215;&nbsp;<i>N</i>. Матрица <i>B</i> называется <i>транспонированной</i> к матрице <i>A</i>, если она имеет размер <i>N</i>&nbsp;&#215;&nbsp;<i>M</i> и ее элементы удовлетворяют следующему соотношению: </p><p class="ptCommentCenter"><i>B</i><sub><i>I</i>,<i>J</i></sub>&nbsp;=&nbsp;<i>A</i><sub><i>J</i>,<i>I</i></sub>, &nbsp; &nbsp; &nbsp; &nbsp;<i>I</i>&nbsp;=&nbsp;1,&nbsp;&#8230;,&nbsp;<i>N</i>, &nbsp; &nbsp;<i>J</i>&nbsp;=&nbsp;1,&nbsp;&#8230;&nbsp;<i>M</i>.</p><p class="ptCommentContinue"></p><p class="ptComment">Пусть <i>A</i> &#8212; матрица размера <i>M</i>&nbsp;&#215;&nbsp;<i>N</i>, <i>B</i> &#8212; матрица размера <i>N</i>&nbsp;&#215;&nbsp;<i>P</i>. Матрица <i>C</i> называется <i>произведением</i> матриц <i>A</i> и <i>B</i> (и обозначается <i>A</i>&#183;<i>B</i>), если она имеет размер <i>M</i>&nbsp;&#215;&nbsp;<i>P</i> и ее элементы удовлетворяют следующему соотношению: </p><p class="ptCommentCenter"><i>C</i><sub><i>I</i>,<i>J</i></sub>&nbsp;=&nbsp;<i>A</i><sub><i>I</i>,1</sub>&#183;<i>B</i><sub>1,<i>J</i></sub>&nbsp;+&nbsp;<i>A</i><sub><i>I</i>,2</sub>&#183;<i>B</i><sub>2,<i>J</i></sub>&nbsp;+&nbsp;&#8230; +&nbsp;<i>A</i><sub>1,<i>N</i></sub>&#183;<i>B</i><sub><i>N</i>,<i>J</i></sub>, &nbsp; &nbsp; &nbsp; &nbsp;<i>I</i>&nbsp;=&nbsp;1,&nbsp;&#8230;,&nbsp;<i>M</i>, &nbsp; &nbsp;<i>J</i>&nbsp;=&nbsp;1,&nbsp;&#8230;&nbsp;<i>P</i>.</p><p class="ptCommentContinue"></p><p class="ptComment">Квадратная матрица <i>A</i> называется <i>верхнетреугольной</i>, если все ее элементы, лежащие ниже главной диагонали, равны нулю (определение <i>главной диагонали</i> см. в задании Matrix80): </p><p class="ptCommentCenter"><i>A</i><sub><i>I</i>,<i>J</i></sub>&nbsp;=&nbsp;0, &nbsp; &nbsp; &nbsp; &nbsp;<i>I</i>&nbsp;&gt;&nbsp;<i>J</i>.</p><p class="ptCommentContinue"></p><p class="ptComment">Квадратная матрица <i>A</i> называется <i>нижнетреугольной</i>, если все ее элементы, лежащие выше главной диагонали, равны нулю: </p><p class="ptCommentCenter"><i>A</i><sub><i>I</i>,<i>J</i></sub>&nbsp;=&nbsp;0, &nbsp; &nbsp; &nbsp; &nbsp;<i>I</i>&nbsp;&lt;&nbsp;<i>J</i>.</p><p class="ptCommentContinue"></p><p class="ptComment">Квадратная матрица <i>A</i> называется <i>трехдиагональной</i>, если равны нулю все ее элементы, не лежащие на главной диагонали и на двух диагоналях, примыкающих к главной: </p><p class="ptCommentCenter"><i>A</i><sub><i>I</i>,<i>J</i></sub>&nbsp;=&nbsp;0, &nbsp; &nbsp; &nbsp; &nbsp;|<i>I</i>&nbsp;&#8722;&nbsp;<i>J</i>|&nbsp;&gt;&nbsp;1.</p>
<p class="ptTask"><span class="ptSpecial">File88</span>. Дан файл вещественных чисел, содержащий ненулевую часть трехдиагональной матрицы (по строкам). Создать новый файл, содержащий все элементы данной матрицы (по строкам). </p>
<h1>Текстовые файлы</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2006, 2012</p>
<p class="ptComment"> Условие вида &#171;дан текстовый файл&#187; означает, что в наборе исходных данных указано <i>имя</i> данного файла (текстовая строка). Все исходные файлы в заданиях данной группы считаются существующими. Элементы исходных файлов следует считывать с помощью стандартных процедур используемого языка программирования. </p><p class="ptComment">Если в задании требуется создать новый файл, то имя создаваемого файла также входит в набор исходных данных (и, как правило, является последним элементом этого набора). Записывать элементы в создаваемые (или модифицируемые) файлы следует с помощью стандартных процедур используемого языка программирования. </p><p class="ptComment">Максимальный размер исходных файлов не устанавливается, поэтому при решении заданий не следует использовать вспомогательные массивы, содержащие все элементы исходных файлов, однако допускается использование <i>вспомогательных файлов</i>. </p><p class="ptComment">Используемые в заданиях двоичные файлы удовлетворяют условиям, которые перечислены в начале описания группы &#171;Двоичные файлы&#187;.</p>
<h2>Текстовые файлы: основные операции</h2>
<p class="ptTask"><span class="ptSpecial">Text10</span>. Дано целое число&nbsp;<i>K</i> и текстовый файл. Вставить пустую строку после строки файла с номером&nbsp;<i>K</i>. Если строки с таким номером нет, то оставить файл без изменений. </p>
<h2>Анализ и&nbsp;форматирование текста</h2>
<p class="ptTask"><span class="ptSpecial">Text39</span>. Дано целое число&nbsp;<i>K</i> (&gt;&nbsp;25) и текстовый файл, содержащий текст, выровненный по левому краю. Абзацы выделяются в нем с помощью <i>красной строки</i> (5&nbsp;начальных пробелов), а пустых строк нет. Отформатировать текст так, чтобы его ширина не превосходила <i>K</i>&nbsp;позиций, и выровнять текст по левому краю, сохранив деление на абзацы. Пробелы в конце строк удалить. Сохранить отформатированный текст в новом текстовом файле. </p>
<h2>Текстовые файлы с&nbsp;числовой информацией</h2>
<p class="ptComment"> В заданиях на обработку текстовых файлов с числовой информацией предполагается, что в изображениях вещественных чисел, содержащихся в текстовых файлах, дробная часть отделяется от целой части десятичной <i>точкой</i>.</p>
<p class="ptTask"><span class="ptSpecial">Text40</span>. Даны два файла целых чисел одинакового размера. Создать текстовый файл, содержащий эти числа, расположенные в два столбца шириной по 30&nbsp;символов (в первом столбце содержатся числа из первого исходного файла, во втором &#8212; из второго файла). В начало и конец каждой строки текстового файла добавить разделитель&nbsp;&#171;|&#187; (код&nbsp;124). Числа выравниваются по правому краю столбца. </p>
<h2>Текстовые файлы: дополнительные задания</h2>
<p class="ptTask"><span class="ptSpecial">Text58</span>. Дан текстовый файл. Подсчитать число появлений в нем каждой <i>строчной</i> (т.&nbsp;е. маленькой) русской буквы и создать строковый файл, элементы которого имеют вид &#171;&lt;буква&gt;&#8211;&lt;число ее появлений&gt;&#187; (например, &#171;а&#8211;25&#187;). Буквы, отсутствующие в тексте, в файл не включать. Строки упорядочить по убыванию числа появлений букв, а при равном числе появлений &#8212; по возрастанию кодов букв. </p>
<h1>Составные типы данных в&nbsp;процедурах и&nbsp;функциях</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2006, 2012</p>
<p class="ptComment"> В каждом задании требуется описать процедуру или функцию и затем использовать ее для обработки исходных данных. Все параметры любой <i>функции</i> считаются входными. Для <i>процедур</i> всегда указывается, какие параметры являются выходными (или одновременно входными и выходными); если о виде параметра процедуры ничего не сказано, то он считается входным.</p>
<h2>Процедуры и&nbsp;функции: работа с&nbsp;файлами</h2>
<p class="ptTask"><span class="ptSpecial">Param55</span>. Описать процедуру StringFileToText(<i>S</i>), преобразующую двоичный строковый файл с именем&nbsp;<i>S</i> в текстовый файл с тем же именем. Используя эту процедуру, преобразовать два данных строковых файла с именами&nbsp;<i>S</i><sub>1</sub> и&nbsp;<i>S</i><sub>2</sub> в текстовые. </p>
<h1>Рекурсия</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2006, 2012</p>
<h2>Рекурсия: разбор выражений</h2>
<p class="ptComment"> Во всех заданиях данной подгруппы предполагается, что исходные строки, определяющие выражения, не содержат пробелов. </p><p class="ptComment">При выполнении заданий не следует использовать оператор цикла.</p>
<p class="ptTask"><span class="ptSpecial">Recur19</span>. Проверить правильность выражения, заданного в виде непустой строки&nbsp;<i>S</i> (выражение определяется по тем же правилам, что и в задании Recur17). Если выражение составлено правильно, то вывести&nbsp;0, в противном случае вывести номер первого ошибочного, лишнего или недостающего символа в строке&nbsp;<i>S</i>. </p>
<h2>Рекурсия: перебор с&nbsp;возвратом</h2>
<p class="ptTask"><span class="ptSpecial">Recur29</span>. Дано дерево глубины&nbsp;<i>N</i>, каждая внутренняя вершина которого имеет 3&nbsp;непосредственных потомка: <i>A</i> с весом&nbsp;1, <i>B</i> с весом&nbsp;0 и&nbsp;<i>C</i> с весом&nbsp;&#8722;1. Корень дерева&nbsp;<i>D</i> имеет вес&nbsp;0. Записать в текстовый файл с данным именем все пути от корня к листьям, удовлетворяющие следующим условиям: суммарный вес элементов для любого начального отрезка пути неположителен, а суммарный вес всех элементов пути равен&nbsp;0. Порядок перебора путей такой же, как в задании Recur25. </p>
<h1>Деревья (с&nbsp;применением указателей)</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2008, 2012</p>
<p class="ptComment"> Все числа, используемые в заданиях на деревья, являются <i>целыми</i>. Все указатели имеют тип PNode и указывают на записи типа TNode; типы PNode и TNode определены в задачнике Programming Taskbook. В заданиях на деревья используются поля Data, Left, Right и Parent записей типа TNode, поэтому при выполнении заданий можно считать, что типы PNode и TNode описаны следующим образом: </p><p class="ptComment">[Pascal] </p><p class="ptCommentQuote"><tt>type</tt><br> &nbsp; &nbsp;<tt>PNode = ^TNode;</tt><br> &nbsp; &nbsp;<tt>TNode = record</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Data: integer;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Left: PNode;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Right: PNode;</tt><br> &nbsp; &nbsp; &nbsp; &nbsp;<tt>Parent: PNode;</tt><br> &nbsp; &nbsp;<tt>end;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[C++] </p><p class="ptCommentQuote"><tt>struct TNode</tt><br><tt>{</tt><br> &nbsp; &nbsp;<tt>int Data;</tt><br> &nbsp; &nbsp;<tt>TNode* Left;</tt><br> &nbsp; &nbsp;<tt>TNode* Right;</tt><br> &nbsp; &nbsp;<tt>TNode* Parent;</tt><br><tt>};</tt><br><tt>typedef TNode* PNode;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">В большинстве заданий при работе с записями типа TNode требуются только поля Data, Left и Right; поле Parent используется лишь в заданиях на обработку дереьев с обратной связью. </p><p class="ptComment"><i>Значением</i> вершины дерева (т.&nbsp;е. записи типа TNode) считается значение его поля Data. </p><p class="ptComment">Так как переменные типа &#171;указатель&#187; предназначены для хранения <i>адресов</i>, в формулировках заданий слова &#171;указатель&#187; (на вершину дерева) и &#171;адрес&#187; (вершины дерева) используются как синонимы. </p><p class="ptComment">В программах на языке Pascal для освобождения динамической памяти, связанной с указателем p типа PNode, следует использовать процедуру Dispose(p), в программах на языке C++ &#8212; оператор delete&nbsp;p или функцию DeleteNode(p).</p>
<h2>Анализ бинарного дерева</h2>
<p class="ptTask"><span class="ptSpecial">Tree22</span>. Дан указатель <i>P</i><sub>1</sub> на корень дерева, содержащего по крайней мере две вершины. Вывести максимальное из значений его <i>внутренних вершин</i> (т.&nbsp;е. вершин, не являющихся листьями). </p>
<h2>Бинарные деревья разбора выражений</h2>
<p class="ptTask"><span class="ptSpecial">Tree78</span>. Дана строка <i>S</i>, содержащая описание числового выражения в следующем формате (так называемый <i>постфиксный бесскобочный формат</i> записи числового выражения): </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt; &lt;выражение&gt; &lt;знак&gt;<tr><td align=left>&lt;знак&gt;      <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p><p class="ptTaskContinue">Выражения отделяются друг от друга и от знаков операций ровно одним пробелом. Создать дерево разбора выражения и вывести указатель на его корень. Структура дерева разбора выражения описана в задании Tree76; для каждой вершины-операции ее левое поддерево должно соответствовать первому операнду данной операции, а правое поддерево &#8212; второму. </p>
<hr noshade>
<p class="ptFooter">Дата генерации страницы: 14.03.2017.</p>
</body></html>
